<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Echo Nie's Blog]]></title>
  <subtitle><![CDATA[Walk step by step]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://niezengying.github.com/"/>
  <updated>2014-11-01T08:59:54.684Z</updated>
  <id>http://niezengying.github.com/</id>
  
  <author>
    <name><![CDATA[Ying Nie]]></name>
    <email><![CDATA[niezengyings@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[cuda学习笔记(1)——核函数]]></title>
    <link href="http://niezengying.github.com/2014/10/30/CUDA%20Learning1/"/>
    <id>http://niezengying.github.com/2014/10/30/CUDA Learning1/</id>
    <published>2014-10-29T17:30:46.000Z</published>
    <updated>2014-11-01T08:58:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>前言</strong><br>两个月前，我接下了移植实验室三维重建系统到gpu上执行的任务，以期实现实时重建的效果。现在，我将结合近两个月的学习更新一系列博文，以总结cuda的核心知识点。关于cuda学习资料，我推荐nvidia官方出版的《gpu高性能编程——cuda实战》与《cuda编程指南》两书，本系列博文也将其作为参考。</p>
<hr>
<h1 id="cuda简介_">cuda简介 </h1>
<p><strong>cuda架构</strong>：是nvidia推出的通用并行计算架构，它包含了一个统一的着色器流水线，使得执行通用计算的程序能够对芯片上的每个alu进行排列,也就是每一个alu单元都可以并行起来进行大规模计算。<br><strong>cuda c</strong>：则是专门为这种架构设计的编程语言。它基于c语言的，因此只要有c语言基础的同学都能很快上手。<br><strong>编程模型</strong>：cuda允许程序员定义成为内核（kernel）的c语言函数，在调用此类函数时，他将<strong>由n个不同的cuda线程并行执行n次</strong>。</p>
<hr>
<h1 id="核函数(kernel)_">核函数(kernel) </h1>
<h2 id="声明与调用">声明与调用</h2>
<p>首先我们来看两段代码：</p>
<p>代码1：<strong><em>标准c</em></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> add(){ }</div><div class="line"></div><div class="line"><span class="keyword">int</span> main (<span class="keyword">void</span>){</div><div class="line">	add();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</div><div class="line">}</div></pre></td></tr></table></figure>



<p>代码2：<strong><em>cuda c</em></strong></p>
<figure class="highlight cuda"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__global__ <span class="keyword">void</span> add_kernel(){ }</div><div class="line"></div><div class="line"><span class="keyword">int</span> main (<span class="keyword">void</span>){</div><div class="line">	add_kernel&lt;&lt;&lt;<span class="number">1</span>,n&gt;&gt;&gt;(); <span class="comment">//kernel</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这两段代码，有两个有区别的地方：</p>
<ul>
<li>kernel函数<code>add_kernel()</code>定义时,带有修饰符<code>__global__</code>;</li>
<li>该函数调用时，带有修饰符<code>&lt;&lt;&lt;1,n&gt;&gt;&gt;</code>。</li>
</ul>
<p>区别解释：</p>
<ul>
<li><code>__global__</code>声明说明符，表示该函数在gpu上运行，属于设备代码；</li>
<li><code>&lt;&lt;&lt;1,n&gt;&gt;&gt;</code>修饰符，则告诉gpu如何调用设备代码，指定每次并行的cuda线程数。</li>
</ul>
<p>其实cuda c就是这么简单，它将设备代码传给nvcc编译，其它代码则交给主机编译器。对主机来说，cuda就这样变成透明的了，是不是很机智？</p>
<hr>
<h2 id="参数传递">参数传递</h2>
<p>根据以上说明，初步了解了kernel的声明与调用, 那么应该如何传递参数给核函数呢？</p>
<p>问1：<strong>如何传递参数给核函数呢？</strong><br>答1： 可以<strong>像c函数一样将参数传递给核函数</strong>，但<strong>kernel中只能调用显存中的数据</strong>。因此我们必须为任何有用数据分配显存空间，并将返回值传给主机。</p>
<p>代码3：<strong><em>带参数的cuda c</em></strong></p>
<figure class="highlight cuda"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">__global__ <span class="keyword">void</span> add_kernel(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *c){</div><div class="line">	<span class="keyword">int</span> i = threadidx.x；</div><div class="line">	c[i] = a[i] + b[i] ;</div><div class="line"> }</div><div class="line"></div><div class="line"><span class="keyword">int</span> main (<span class="keyword">void</span>){</div><div class="line">	<span class="keyword">int</span> h_c;</div><div class="line">	<span class="keyword">int</span> *dev_c;</div><div class="line">	cudamalloc((<span class="keyword">void</span>**)&dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//分配显存空间</span></div><div class="line">	</div><div class="line">	add_kernel&lt;&lt;&lt;<span class="number">1</span>,n&gt;&gt;&gt;（dev_a, dev_b, dev_c); <span class="comment">//假设dev_a, dev_b已赋值</span></div><div class="line"></div><div class="line">	cudamemcpy(&h_c, dev_c, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudamemcpydevicetohost); <span class="comment">//将显存数据传回主机	</span></div><div class="line">	cudafree(dev_c);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>代码3的作用是，将大小为n的向量a和向量b相加，并将结果存入c。main函数里多了三行代码<code>cudamalloc()/cudafree()</code>和<code>cudamemcpy()</code>;它们均是cuda提供的标准函数，分别负责<strong>分配/设备设备空间</strong>和<strong>主机与设备的数据交换</strong>。</p>
<p><strong>函数原型：</strong><br><code>cudaerror_t cudamalloc(void** devptr, size_t count);</code><br><code>cudaerror_t cudafree(void* devptr);</code><br><code>cudaerror_t cudamemcpy(void* dst, const void* src, size_t count, enum cudamemcpykind kind);</code><br>说明：<code>cudamemcpy()</code>从src指向的存储器区域将count个字符复制到dst指向的区域；<br>其中kind是<code>cudamemcpyhosttohost</code>、<code>udamemcpyhosttodevice</code>、<code>cudamemcpydevicetohost</code>或<code>cudamemcpydevicetodevice</code>之一。</p>
<hr>
<h2 id="线程并行">线程并行</h2>
<p>学到这里，我们已经知道如何声明和调用核函数了，并且已经能正确传递参数给它，但依然有个问题待解决。</p>
<p>问2：<strong>应该如何定义核函数，以使线程并行执行并准确获取所需参数呢？</strong><br>答2：执行内核的每个线程都会被分配一个独特的线程id，可通过内置的threadidx变量在内核中访问此id。我们可以利用线程id去该线程索引所需的参数值；</p>
<p>依然以代码3为例，<code>add_kernel()</code>实际所做的工作也就是将a,b两组数据的对应元素两两相加。该函数中的代码:<br><code>int i = threadidx.x</code>作用在于获取线程id(以0开始计数)；<br><code>c[i] = a[i] + b[i]</code>则表示，每个线程将线程id作为索引号，获取该线程对应处理的元素；<br>这样就能使n个线程并行起来，每个线程实现其中一组元素的加法操作，从而避免单线程循环n次计算，大大提高运算速度。</p>
<hr>
<h1 id="总结">总结</h1>
<p>总结起来，<br><strong>编程模型</strong>： 定义称为kernel的c语言函数，kernel将有n个不同的cuda线程并行执行n次；<br><strong>声明与调用</strong>： <code>__global__ void kernel ( void ){};</code><br>            <code>kernel&lt;&lt;&lt;...&gt;&gt;&gt; (); //&lt;&lt;&lt;...&gt;&gt;&gt; 指定每次调用的cuda线程数。</code><br><strong>参数传递</strong>：核函数与c函数参数传递形式一样，但核函数参数必须为设备存储区域的数据。<br><strong>线程并行</strong>：每个线程利用线程id去索引合适的元素进行计算。</p>
<p>如果看到这里，对并行编程还不太明白，没关系。我将在下一篇博文详细介绍cuda并行编程以及线程层次结构。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>前言</strong><br>两个月前，我接下了移植实验室三维重建系统到gpu上执行的任务，以期实现实时重建的效果。现在，我将结合近两个月的学习更新一系列博文，以总结cuda的核心知识点。关于cuda学习资料，我推荐nvidia官方出版的《gpu高性能编程—]]>
    </summary>
    
      <category term="cuda c" scheme="http://niezengying.github.com/tags/cuda-c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo Introduction]]></title>
    <link href="http://niezengying.github.com/2014/10/30/Hexo%20Intro/"/>
    <id>http://niezengying.github.com/2014/10/30/Hexo Intro/</id>
    <published>2014-10-29T16:49:47.000Z</published>
    <updated>2014-10-30T06:52:51.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="Other" scheme="http://niezengying.github.com/tags/Other/"/>
    
  </entry>
  
</feed>
